# -*- coding: utf-8 -*-
"""CliqueCoverCode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10VjToBg28WUarEttPW9_QBPuz6ROVuVY
"""

import networkx as nx
from dwave.system import DWaveSampler, EmbeddingComposite
from dimod import BinaryQuadraticModel
from collections import defaultdict

# Define the graph (example)
G = nx.gnp_random_graph(10, 0.5)  # Graph with 10 nodes and 50% probability of edge creation
print(f'Graph with {len(G.nodes)} nodes and {len(G.edges)} edges, out of {len(G.nodes) * (len(G.nodes)-1) // 2} possible edges')

# Parameters
num_cliques = 3  # Adjust based on the graph's structure

# Formulating the QUBO for clique cover
def clique_cover_qubo(graph, num_cliques):
    n = len(graph)
    Q = defaultdict(float)


    """
     Variable x[i][k] is 1 if node i is in clique k
     i: vertex index
     k: color
     lambda function maps a pair of indices (i, k) into a single index.
    This is useful when converting a 2D problem into a 1D problem.
    """
    x = lambda i, k: i * num_cliques + k

    # Each node must be in exactly one clique
    for i in range(n):
        for k in range(num_cliques):
            Q[(x(i, k), x(i, k))] -= 1
            for k2 in range(k + 1, num_cliques):
                Q[(x(i, k), x(i, k2))] += 2

    # Each edge must be covered by at least one clique
    for u, v in graph.edges():
        for k in range(num_cliques):
            Q[(x(u, k), x(v, k))] -= 1

    return dict(Q)

# Generate QUBO
Q = clique_cover_qubo(G, num_cliques)

# Create Binary Quadratic Model
bqm = BinaryQuadraticModel.from_qubo(Q)

# Use D-Wave's sampler to solve the Ising model
sampler = EmbeddingComposite(DWaveSampler())
response = sampler.sample(bqm, num_reads=100)

# Parse the best solution
best_solution = response.first.sample

# Print the best solution
print("Best solution:", best_solution)

# Interpret the solution
cliques = [[] for _ in range(num_cliques)]
for i in range(len(G.nodes)):
    for k in range(num_cliques):
        if best_solution[i * num_cliques + k] == 1:
            cliques[k].append(i)

# Print the cliques
print("Cliques found:", cliques)